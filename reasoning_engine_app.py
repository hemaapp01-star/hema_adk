"""
Reasoning Engine Application for Vertex AI Agent Engine deployment.

This module provides the query interface required by Vertex AI Reasoning Engine.
It wraps the Request Coordinator Agent to handle long-running blood request coordination.
"""

import os
import logging
import asyncio
from typing import Dict, Any
import firebase_admin
from firebase_admin import credentials
from google.adk.sessions import VertexAiSessionService
from google.adk.runners import Runner
from google.genai import types

# Initialize Firebase - conditional for deployment vs runtime
try:
    if not firebase_admin._apps:
        # Try to use service account key if available
        if os.path.exists("hema-key.json"):
            cred = credentials.Certificate("hema-key.json")
            firebase_admin.initialize_app(cred)
        else:
            # Use Application Default Credentials (works on Vertex AI)
            firebase_admin.initialize_app()
            logger.info("Using Application Default Credentials for Firebase")
except Exception as e:
    # During deployment, Firebase may not be needed
    logger.warning(f"Firebase initialization deferred: {e}")

from hema_agent.request_coordinator_agent import create_request_coordinator_agent

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Get configuration from environment
PROJECT_ID = os.environ.get("GOOGLE_CLOUD_PROJECT", "hema-63b81")
LOCATION = os.environ.get("GOOGLE_CLOUD_LOCATION", "us-central1")
AGENT_ENGINE_ID = os.environ.get("GOOGLE_CLOUD_AGENT_ENGINE_ID", "5294582794834411520")


class HemaReasoningEngineApp:
    """
    Application class for Vertex AI Reasoning Engine deployment.
    
    This class provides the query() method interface required by Reasoning Engine
    and manages long-running request coordination tasks with VertexAI sessions.
    """
    
    def __init__(self):
        """Initialize the Reasoning Engine application with VertexAI session service."""
        # Initialize VertexAI Session Service
        self.session_service = VertexAiSessionService(
            PROJECT_ID,
            LOCATION,
            AGENT_ENGINE_ID
        )
        self.active_coordinators: Dict[str, Any] = {}
        logger.info(f"Initialized Hema Reasoning Engine App with VertexAI sessions")
        logger.info(f"Project: {PROJECT_ID}, Location: {LOCATION}, Engine: {AGENT_ENGINE_ID}")
    
    async def query(self, input_data: Dict[str, Any]) -> Dict[str, Any]:
        """
        Main query method called by Vertex AI Reasoning Engine.
        
        Args:
            input_data: Dictionary containing:
                - provider_id: Healthcare provider ID
                - request_id: Blood request ID
                - request: Blood request data
                
        Returns:
            Dictionary with status and auto-generated session ID
        """
        try:
            logger.info(f"Received query with input: {input_data}")
            
            # Extract parameters
            provider_id = input_data.get("provider_id")
            request_id = input_data.get("request_id")
            request_data = input_data.get("request")
            
            if not all([provider_id, request_id, request_data]):
                return {
                    "error": "Missing required fields: provider_id, request_id, request",
                    "status": "failed"
                }
            
            # Create user ID (for session management)
            user_id = f"provider_{provider_id}"
            app_name = "hema_blood_coordinator"
            
            # ✅ Create session - Vertex AI auto-generates the session ID
            logger.info(f"Creating session for user: {user_id}")
            session = await self.session_service.create_session(
                app_name=app_name,
                user_id=user_id,
                ttl="604800s"  # 7 days TTL
            )
            
            # ✅ The session ID is auto-generated by Vertex AI
            session_id = session.id
            logger.info(f"Session created with ID: {session_id}")
            
            # Store request metadata in session state
            await self.session_service.update_session(
                app_name=app_name,
                user_id=user_id,
                session_id=session_id,
                state={
                    "provider_id": provider_id,
                    "request_id": request_id,
                    "status": "coordinating"
                }
            )
            
            # Start coordination asynchronously
            asyncio.create_task(
                self._start_coordination(
                    app_name, user_id, session_id, request_data
                )
            )
            
            return {
                "status": "started",
                "session_id": session_id,  # ✅ Return the auto-generated session ID
                "user_id": user_id,
                "message": "Blood request coordination started successfully"
            }
            
        except Exception as e:
            logger.error(f"Error in query: {str(e)}", exc_info=True)
            return {
                "error": str(e),
                "status": "failed"
            }
    
    async def _start_coordination(
        self, 
        app_name: str, 
        user_id: str, 
        session_id: str, 
        request_data: Dict
    ):
        """
        Start the request coordination process.
        
        Args:
            app_name: Application name
            user_id: User identifier
            session_id: Auto-generated session ID from Vertex AI
            request_data: Blood request data
        """
        try:
            logger.info(f"Starting coordination for session {session_id}")
            
            # Create coordinator agent
            coordinator = create_request_coordinator_agent(session_id, request_data)
            
            # Store active coordinator
            self.active_coordinators[session_id] = coordinator
            
            # Run coordination (this is a long-running task)
            await coordinator.coordinate_request()
            
            # Update session state on completion
            await self.session_service.update_session(
                app_name=app_name,
                user_id=user_id,
                session_id=session_id,
                state={"status": "completed"}
            )
            
            # Clean up after completion
            if session_id in self.active_coordinators:
                del self.active_coordinators[session_id]
            
            logger.info(f"Coordination completed for session {session_id}")
            
        except Exception as e:
            logger.error(f"Error in coordination: {str(e)}", exc_info=True)
            
            # Update session state on error
            try:
                await self.session_service.update_session(
                    app_name=app_name,
                    user_id=user_id,
                    session_id=session_id,
                    state={"status": "failed", "error": str(e)}
                )
            except:
                pass
            
            if session_id in self.active_coordinators:
                del self.active_coordinators[session_id]


# Create the application instance for deployment
app = HemaReasoningEngineApp()
